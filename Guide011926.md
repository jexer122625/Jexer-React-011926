Below is a concrete, step‑by‑step guide to run both the Flask backend and the React frontend on your local machine.

I’ll assume you’re starting from scratch in a new project folder.

1. Prerequisites
Make sure you have:

Python: 3.9+
Check: python --version (or python3 --version)
Node.js & npm: Node 18+ recommended
Check: node -v and npm -v
Git (optional, but convenient)
2. Project structure
We’ll use this structure:

wow-510k/
  backend/
    app.py
    requirements.txt
  frontend/
    (React app created by Vite or CRA)
You can change names, but I’ll assume wow-510k as the root folder.

3. Backend: Flask + LLMs
3.1. Create backend folder and files
In a terminal:

mkdir -p wow-510k/backend
cd wow-510k/backend
Create a requirements.txt file:

flask
openai
google-generativeai
pymupdf
Save your updated app.py (the version with the modern google.generativeai integration I gave you earlier) into wow-510k/backend/app.py.

3.2. Create and activate a virtual environment
From wow-510k/backend:

On macOS/Linux:

python3 -m venv .venv
source .venv/bin/activate
On Windows (PowerShell):

python -m venv .venv
.\.venv\Scripts\Activate.ps1
You should now see (.venv) in your terminal prompt.

3.3. Install backend dependencies
Still in wow-510k/backend with the venv active:

pip install --upgrade pip
pip install -r requirements.txt
3.4. (Optional but recommended) Set API keys as environment variables
You can either:

Set them as environment variables; or
Enter them via the UI later (the /set_api_keys endpoint).
Option A – Environment variables

macOS/Linux (bash/zsh):

export OPENAI_API_KEY="your_openai_key_here"
export GEMINI_API_KEY="your_gemini_key_here"   # or GOOGLE_API_KEY
Windows (PowerShell):

setx OPENAI_API_KEY "your_openai_key_here"
setx GEMINI_API_KEY "your_gemini_key_here"
Then open a new terminal or re-run your shell so the variables are available.

Option B – Use React UI

Start the backend and frontend (instructions below).
Type your OpenAI and Gemini API keys in the Settings sidebar and click “Save Keys”. The keys will be stored in memory on the backend for that session.
3.5. Run the Flask backend locally
From wow-510k/backend with the venv active:

python app.py
You should see something like:

 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
 * Debug mode: on
The backend is now running at http://localhost:5000.

You can test quickly by visiting http://localhost:5000/ in a browser; you should see the minimal “Backend is running” page.

4. Frontend: React (Vite)
I’ll assume Vite + React for a clean setup.

4.1. Create the React app
Open a new terminal (keep the backend terminal running), go to the project root, and create the frontend:

cd path/to/wow-510k
npm create vite@latest frontend -- --template react
This will create a frontend folder with a basic React app.

Now install its dependencies:

cd frontend
npm install
4.2. Replace the default React files with the provided code
You’ll have these files (among others):

src/App.jsx
src/App.css
src/main.jsx
Replace their contents with the ones I provided:

src/App.jsx → paste the full React component code from the previous answer.

src/App.css → paste the CSS from the previous answer.

src/main.jsx → minimal bootstrap:

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./App.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
Make sure the fetch calls in App.jsx are pointing to relative paths like /set_api_keys, /transform_submission, etc. (they already do in the code I gave you).

4.3. Configure Vite dev server proxy (to avoid CORS issues)
While developing, React will run at http://localhost:5173 and Flask at http://localhost:5000. To keep your frontend code using simple paths like /transform_submission, configure a proxy in vite.config.js.

Open vite.config.js (in frontend) and edit it like this:

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/set_api_keys': 'http://localhost:5000',
      '/transform_submission': 'http://localhost:5000',
      '/transform_checklist': 'http://localhost:5000',
      '/run_review': 'http://localhost:5000'
    }
  }
})
This tells Vite:

When the browser calls /transform_submission (from http://localhost:5173), Vite forwards that call to http://localhost:5000/transform_submission on your machine.
You do not need CORS configuration in Flask for local dev if you use this proxy.

4.4. Run the React dev server
From wow-510k/frontend:

npm run dev
You should see output like:

  VITE vX.X.X  ready in Xs

  ➜  Local:   http://localhost:5173/
Open http://localhost:5173 in your browser.

5. Using the app locally
With both servers running:

Backend: python app.py → http://localhost:5000
Frontend: npm run dev → http://localhost:5173
In your browser go to http://localhost:5173 and you should see:

A Settings sidebar (theme, language, API keys, painter styles).
Main sections:
“Paste Submission (text/markdown) or upload PDF”
“Paste Checklist or upload CSV”
“Run Review”
Workflow:

Set API keys

In Settings → enter OpenAI and/or Gemini keys → click Save Keys.
Status should change to something like saved.
Transform a submission

Paste or upload a PDF in the first panel.
Choose a model (e.g., gpt-4o-mini or gemini-2.5-flash).
Click Transform Submission.
The output should appear in the “result” box of that section.
Transform a checklist

Paste or upload CSV/text in the second panel.
Click Transform Checklist.
Run a review

Either paste refined submission/checklist markdown into the third section or leave them blank to reuse the last outputs.
Click Run Review.
LLM-generated review report should appear.
6. (Optional) One-command scripts
To simplify:

Backend run script (Unix-like)
Create a file run_backend.sh inside backend:

#!/usr/bin/env bash
source .venv/bin/activate
python app.py
Make executable:

chmod +x run_backend.sh
./run_backend.sh
Frontend run script (Unix-like)
In frontend you already have npm run dev. If you want a shell wrapper:

#!/usr/bin/env bash
npm run dev
7. (Optional) Production-style build (local only)
If you later want to see a production build of the frontend:

From wow-510k/frontend:

npm run build
npm run preview
npm run build creates a static bundle in dist/.
npm run preview serves it locally (usually at http://localhost:4173).
For true production, you might serve that dist/ folder via Nginx, or configure Flask to serve those static files — but for now, the dev setup is enough.

8. Twenty comprehensive follow-up questions
What operating system are you primarily using (Windows, macOS, or Linux), and do you want OS-specific helper scripts or instructions (e.g., .bat vs .sh)?
Would you like a ready-made requirements.txt and package.json snapshot that exactly matches the versions I recommend to minimize dependency conflicts?
Do you prefer a single docker-compose setup that runs both the Flask backend and React frontend in containers, instead of managing Python/Node directly on your host machine?
Would you like a sample .env file setup and code changes to load environment variables (API keys, ports, etc.) consistently across backend and frontend?
Do you want to change the default ports (5000 for backend, 5173 for frontend) and would you like guidance on how to adjust them in both Flask and Vite configurations?
Are you comfortable with the Vite proxy approach, or would you prefer to have the React app call http://localhost:5000/... directly and configure CORS in Flask instead?
Would you like instructions on how to bundle the built React app (dist/) into the Flask app so the entire solution is served from a single http://localhost:5000 origin?
Do you need help verifying that the google-generativeai and openai packages are correctly installed and that LLM calls are working (e.g., by adding a simple /health or /test_llm endpoint)?
Should we add basic logging to the Flask app so you can see each incoming request (model, route, and duration) while you’re testing locally?
Would you like a minimal automated test (e.g., using pytest and requests) to confirm that /transform_submission, /transform_checklist, and /run_review all respond correctly on your local setup?
Are you planning to use only Gemini, only OpenAI, or both during local development, and do you want to disable one provider conditionally to reduce confusion?
Would you like guidance on how to keep your API keys safe on your local machine (e.g., using a .env file that you never commit to Git)?
Do you want a short script or Makefile (e.g., make dev) that starts both the backend and frontend dev servers with a single command?
Would it help to have screenshots or a minimal UI checklist to confirm that the React app is wired correctly (e.g., status text changes, error messages, and result panels updating)?
Are you interested in using a code editor configuration (VS Code settings, recommended extensions) tailored for this project (Python + React + TypeScript option)?
Do you want to parameterize the backend URL in the frontend (e.g., via VITE_API_BASE_URL) so you can easily switch between local and remote backends?
Would you like me to show how to run the backend in debug vs production mode (e.g., flask run vs gunicorn) even for local testing scenarios?
Are you planning to share your local setup with colleagues, and do you need onboarding instructions or a README template you can drop into the repo?
Would you like a quick troubleshooting guide for common local issues (port already in use, missing venv, permission issues on Windows, etc.)?
Do you want to extend this local setup into a full development workflow with Git branching, code formatting (Black/Prettier), and linting (Flake8/ESLint) from the start?


Below is a detailed, beginner‑friendly deployment guide for your previous program (the Flask app with WOW UI, AI Note Keeper, agents.yaml, OpenAI/Gemini integration).

It includes:

Local preparation (so you know your app works before deploying).
Small code tweak for deployment friendliness.
Three free online deployment options:
Render
Railway
Replit
Important:
PyWebView (run.py) is only for local desktop apps.
For online deployment, you deploy only the Flask app (app.py) as a normal web service.

1. Prepare Your Project Locally
1.1. Project structure
On your development machine, you should have something like:

wow-510k/
  app.py
  run.py
  requirements.txt
  pyproject.toml         (optional)
  agents.yaml            (optional)
  README.md              (optional)
app.py – Flask web app (the one we just built with WOW UI, Note Keeper, agents).
run.py – PyWebView desktop launcher (not used online).
requirements.txt – dependencies.
agents.yaml – optional, defines agents for the Note Keeper.
1.2. Virtual environment (optional but recommended for local testing)
From the wow-510k folder:

Windows:

python -m venv venv
venv\Scripts\activate
macOS / Linux:

python3 -m venv venv
source venv/bin/activate
Install dependencies:

pip install -r requirements.txt
1.3. Test app.py locally
Run only the Flask app:

python app.py
In your browser, open:

http://127.0.0.1:5000
You should see the WOW 510(k) Assistant UI with:

Submission, Checklist, Review
AI Note Keeper
Agents (if agents.yaml is present)
Editable prompts and edit/preview outputs
Copy/download buttons, LLM test, etc.
Press Ctrl + C in the terminal to stop.

2. Small Code Tweak for Cloud Deployment
Many cloud platforms expect your app to:

Listen on 0.0.0.0
Use the PORT environment variable they provide
In your current app.py you have:

if __name__ == "__main__":
    # For local debugging; in production use a proper WSGI server
    app.run(host="0.0.0.0", port=5000, debug=True)
Change this to:

if __name__ == "__main__":
    import os
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=False)
This way:

Locally: it still runs on port 5000.
On cloud: it uses whatever PORT the platform sets.
Save app.py and re‑test locally:

python app.py
3. Shared Deployment Requirements
Before any cloud option:

GitHub repository (recommended)

Create a free GitHub account if you don’t have one.
Initialize a repo (e.g., wow-510k-assistant).
Add app.py, requirements.txt, agents.yaml, etc.
Commit and push.
Environment variables (API keys)

You will set these in each platform’s web UI:
OPENAI_API_KEY
GEMINI_API_KEY (or GOOGLE_API_KEY)
Start command

Most platforms can run:
python app.py or better (for production):
gunicorn app:app (if you add gunicorn to requirements).
For beginners, python app.py is fine; the platforms we’ll use handle basic routing and health.

4. Deployment Option 1 – Render (Free Web Service)
Render: https://render.com/
Easy UI, GitHub integration, free tier with auto‑sleep.

4.1. Prepare your repo
Ensure your GitHub repo contains:

app.py
requirements.txt
(optional) agents.yaml
requirements.txt should include at least:

Flask>=3.0,<4.0
openai>=1.40.0
google-genai>=0.5.0
PyMuPDF>=1.24.0
PyYAML>=6.0
If you don’t need PyWebView online, you can omit pywebview from the deployment requirements (it’s desktop-only). It’s okay to leave it; Render can install it too.

4.2. Create a Render account and connect GitHub
Go to https://render.com
Sign up (GitHub login works well).
Click New + → Web Service.
Select Build and deploy from a Git repository.
Choose your GitHub repo (wow-510k-assistant).
4.3. Configure the Web Service
On the “Create a Web Service” page:

Name: wow-510k-assistant (any name).

Region: choose one near you.

Branch: usually main or master.

Root Directory: / (if your code is at the repo root).

Runtime: Python 3.

Build Command:

pip install -r requirements.txt
Start Command:

python app.py
(Later you can switch to gunicorn app:app if you like.)

Instance Type: Free (can auto‑sleep).

Click Advanced to set environment variables:

Add:
OPENAI_API_KEY = your-openai-key
GEMINI_API_KEY = your-gemini-key
Click Create Web Service.

Render will:

Clone your repo.
Install dependencies.
Run python app.py.
4.4. Access your app
Once the deployment succeeds, Render shows a public URL like:

https://wow-510k-assistant.onrender.com
Click it to open your app in the browser.

Use the UI as usual (LLM test, transforms, Note Keeper, etc.).

5. Deployment Option 2 – Railway (Free Web Service)
Railway: https://railway.app/
Beginner‑friendly, good free tier, GitHub integration.

5.1. Sign up and create a project
Go to https://railway.app/
Sign up (GitHub login is easiest).
Click New Project → Deploy from GitHub repo.
Choose your wow-510k-assistant repo.
5.2. Configure build and start commands
Railway uses Nixpacks and usually auto‑detects Python, but ensure:

In the project “Service” settings → Variables:

Add:
OPENAI_API_KEY
GEMINI_API_KEY
In Settings → Deployments or the service “Settings”:

Start Command:
python app.py
Or, if you prefer:
gunicorn app:app
If Railway shows a Port setting, make sure it’s using the PORT environment variable (it usually does). Our app.py is already reading PORT with a default of 5000.

5.3. Deploy and test
Railway will build and deploy automatically when you set it up.
In the Deployments tab, wait for a green status.
Railway gives you a public URL like:
https://wow-510k-assistant.up.railway.app
Open that URL in your browser and use the app.

6. Deployment Option 3 – Replit (Free Online IDE + Hosting)
Replit: https://replit.com/
Runs your code in the cloud, with a web preview.

6.1. Import your repo into Replit
Go to https://replit.com/
Sign up / log in.
Click + Create Repl.
Choose the Import from GitHub option.
Paste your GitHub URL (e.g., https://github.com/yourname/wow-510k-assistant).
Choose language: Python if prompted.
Replit will clone your repo.

6.2. Configure Replit to install dependencies and run Flask
In the Replit editor:

Open the Shell (bottom or side pane).
(Optional) Create a venv; Replit often runs without venv, but for simplicity we can install directly:
pip install -r requirements.txt
To make Replit install dependencies automatically and run the app:

Open the file .replit (create it if it doesn’t exist) and set:
run = "pip install -r requirements.txt && python app.py"
If Replit uses replit.nix automatically, you can still keep this run command.

6.3. Set environment variables (secrets)
In Replit, click the “Secrets” icon (lock icon) on the left.
Add:
Key: OPENAI_API_KEY, Value: your OpenAI key.
Key: GEMINI_API_KEY, Value: your Gemini key.
These are now available to your app as environment variables.

6.4. Run and access
Click the big Run button at the top.
Replit will:
Run pip install -r requirements.txt
Start python app.py
A web preview window will appear, with a URL like:
https://wow-510k-assistant.yourusername.repl.co
You can open it in a new tab to use the app.

If Replit complains about port:

Make sure app.py is using:

port = int(os.environ.get("PORT", 5000))
app.run(host="0.0.0.0", port=port, debug=False)
Replit usually passes a PORT value.

7. Notes about PyWebView and Online Deployment
PyWebView (run.py) is for local desktop use only.

It opens a native window on your machine and points to http://127.0.0.1:5000.
Cloud platforms cannot display native windows; they only expose HTTP endpoints.
For online deployment:

Ignore run.py on the server.
Deploy only app.py with requirements.txt.
Access your app via the platform’s URL in a normal browser.
You can still keep using run.py locally if you want a desktop experience on your machine.
